Mybatis缓存
  缓存：内存中的数据，对数据库查询结果的保留
  Mybatis一级缓存：默认是开启的
javacode01 演示一级缓存
//禁用一级缓存，在sql的标签上写 flushCache="true"(将一级缓存从sqlSession级别降低为statement级别。实现了查询就清空缓存)
//解决了分布式环境下一级缓存脏读问题，也就是缓存在A机器的数据，和B机器上的数据不一致
//分布式情况下就禁用一级缓存
javacode02 演示二级缓存 当执行了sqlSession.commit()或sqlSession.close()才会把一级缓存刷新到二级缓存中
  注解开发：
    Step01.在sqlMapConfig.xml中配置如下：
        <settings>
            <setting name="cacheEnabled" value="true"/>
        </settings>
    Step02.在接口类顶部加 @CacheNamespace(implementation = PerpetualCache.class)//开启二级缓存
    Step03.模型要实现Serializable
    如果是写<select>,那么可以控制该条sql是否开启二级缓存：<select useCache="false"  flushCache="false"> flushCache:增删改后是否清空缓存，默认是true

  配置文件开发:
    Step01.在sqlMapConfig.xml中配置如下：
       <settings>
           <setting name="cacheEnabled" value="true"/>
       </settings>
    Step02.在xxMapper.xml中加一个：<cache></cache>
    Step03.模型要实现Serializable
    如果是写@Select,么可以控制该条sql是否开启二级缓存：在@Select上面写: @Options(useCache = false , flushCache = false)

javacode03 演示mybatis-redis
分布式环境下，Mybatis自带的二级缓存无效
 解决：使用第三方库解决分布式缓存，如redis 将各个服务器的缓存都缓存到redis中
 实现：
   <dependency>
       <groupId>org.mybatis.caches</groupId>
       <artifactId>mybatis-redis</artifactId>
       <version>1.0.0-beta2</version>
   </dependency>
   在模型类顶部中加注解：@CacheNamespace(implementation = RedisCache.class)//开启分布式二级缓存
   链接并启动redis:
     创建：resis.properties
     启动resis服务
   结果

javacode04 自定义Mybatis插件 看：Mybatis插件使用.jpg MyPlugin.class
Mybatis插件：
  对于Mybatis来说，插件就是拦截器 四大对象返回的都是动态代理调用invoke后的对象
            Executor 增删改查
        StatementHandler  sql语法预编译
ParamterHandler    ResultSetHandler
  设置参数                设置结果集
通过拦截StatementHandler对象，可以进行修改sql

Mybatis所允许拦截的方法如下：拦截就是在以下原方法之前执行自定义逻辑
  Executor：update query commit rollback等方法
  StatementHandler：prepare parameterize batch update query等方法
  ParameterHandler：getParameterObject,setParameters等方法
  ResultSetHandler：handleResultSets,handleOutParameters等方法

javacode05 Mybatis中使用第三方插件
  1.pageHelper分页插件
    STEP01.导包
      <!--分页助手 -->
      <dependency>
          <groupId>com.github.pagehelper</groupId>
          <artifactId>pagehelper</artifactId>
          <version>3.7.5</version>
      </dependency>
      <dependency>
          <groupId>com.github.jsqlparser</groupId>
          <artifactId>jsqlparser</artifactId>
          <version>0.9.1</version>
      </dependency>
    STEP02.在sqlMapConfig.xml进行配置<plugin>
      <plugins>
          <plugin interceptor="com.github.pagehelper.PageHelper">
              <property name="dialect" value="mysql"/>
          </plugin>
      </plugins>
    STEP03.使用
      PageHelper.startPage(1,2);
      List<User> users = this.userMapper.getAllUsers();
      for (User user : users) {
          System.out.println(user);
      }
      PageInfo<User> userPageInfo = new PageInfo<>(users);
      System.out.println(userPageInfo);
      //总条数：getTotal()
      //总页数：getPages()
      //当前页：getPageNum()
      //每页显示的条数：getPageSize()


  javacode06 Mybatis插件机制 - 通用mapper:
    为了解决在每个单表接口中都写一套CURD的sql
    使用通用mapper
      STEP01.导包：
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper</artifactId>
            <version>3.1.2</version>
        </dependency>
      STEP02.在sqlMapConfig.xml进行配置<plugin>
        <plugin interceptor="tk.mybatis.mapper.mapperhelper.MapperInterceptor">
            <!--指定当前通用mapper接口使用的是哪一个-->
            <property name="mappers" value="tk.mybatis.mapper.common.Mapper"/>
        </plugin>
      STEP03.设置模型类
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY) //设置主键自增
      STEP04.定义一个通用mapper UserMapper接口
        public interface UserMapper extends Mapper<User> { //import tk.mybatis.mapper.common.Mapper;

        }
      STEP05.测试
        private UserMapper userMapper;
        this.userMapper = this.sqlSession.getMapper(UserMapper.class);
        增：
          int insert = this.userMapper.insert(null);//null也会保存
          int i = this.userMapper.insertSelective(null);//null不会被保存
        删：
          int delete = this.userMapper.delete(user);//根据实体条件进行删除
          int i2 = this.userMapper.deleteByPrimaryKey(1);//根据主键进行删除
        改：
          int i1 = this.userMapper.updateByPrimaryKey(user1);//更新
        查：
          User user1 = this.userMapper.selectOne(user);//根据实体条件进行查询
          User user2 = this.userMapper.selectByPrimaryKey(1);根据主键进行查询
          List<User> select = this.userMapper.select(null);//查询全部
          自定义条件查询：
            Example example = new Example(User.class);
            example.createCriteria().andEqualTo("id",12);//自定义条件查询
            List<User> users = this.userMapper.selectByExample(example);





