Spring 中IOC基础：
  三种方式：
    1.纯xml形式
      javaSE应用 :ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
                  或 new FileSystemXmlApplicationContext("c:/beans.xml");
                  或 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
                     该ClassPathXmlApplicationContext类有关闭容器的方法close
      javaWeb应用: ContextLoaderListener（监听器去加载xml）
        web.xml:
          <web-app>
            <display-name>Archetype Created Web Application</display-name>
            <!--配置Spring ioc容器的配置文件-->
            <context-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>classpath:applicationContext.xml</param-value>
            </context-param>
            <!--使用监听器启动Spring的IOC容器-->
            <listener>
              <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
            </listener>
          </web-app>

    2.xml+注解形式
      启动方式同上

    3.纯注解形式 找xml标签(属性)和注解的一一对应关系
      javaSE应用：ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);
      javaWeb应用: ContextLoaderListener （监听器去加载注解配置类）
        web.xml:
          <web-app>
            <display-name>Archetype Created Web Application</display-name>
            <!--告诉ContextloaderListener知道我们使用注解的方式启动ioc容器-->
            <context-param>
              <param-name>contextClass</param-name>
              <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
            </context-param>
            <!--配置启动类的全限定类名-->
            <context-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>com.lagou.edu.SpringConfig</param-value>
            </context-param>
            <!--使用监听器启动Spring的IOC容器-->
            <listener>
              <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
            </listener>
          </web-app>

SpringIOC的使用：
  <!--引入spring容器-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.12.RELEASE</version>
  </dependency>
javacode01.纯xml方式
    STEP01.
      准备xml文件，通常取名为applicationContext.xml
    STEP02.
      启动容器
      javaSE应用 :ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
                  或 new FileSystemXmlApplicationContext("c:/beans.xml");//不推荐！！！
      javaWeb应用:
        <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-web</artifactId>
          <version>5.1.12.RELEASE</version>
        </dependency>
        在WEB-INF/web.xml中
          <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
          </context-param>
          <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
          </listener>
    纯xml创建bean的三种方式：
      01. 无参构造器(推荐)：
        <bean id="connectionUtils" class="com.lagou.edu.utils.ConnectionUtils"></bean>
      02. 为了自己new的对象加入到springIOC管理(静态方法实例化bean)
        <bean id="connectionUtils" class="com.lagou.edu.factory.CreateBeanFactory" factory-method="getInstanceStatic"></bean>
      03.实例化方法(非静态方法)
        <bean id="createBeanFactory" class="com.lagou.edu.factory.CreateBeanFactory"></bean>
        <bean id="connectionUtils" factory-bean="createBeanFactory" factory-method="getInstance"></bean>
      以上三种的统一javaSE使用：
        //加入到容器中
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        //注入到代码中
        ConnectionUtils connectionUtils = (ConnectionUtils) applicationContext.getBean("connectionUtils");
      javaWEB的使用，可以重新看视频

      bean标签的scope属性：
        就是bean的作用范围
        scope="singleton":单例 容器中只有一个对象，每次getBean都是同一个对象 (默认值)
        scope="property": 多例 每次getBean,都会返回一个新的对象，spring只创建对象，不管理对象
      bean标签的init-method属性：init-method="init"
        该bean在容器中一旦被实例化，就会调用该方法; 多例情况下，只要调getBean就会调用该方法
        总结：只要一被实例化new，就调用该方法
      bean标签的destroy-method属性：destroy-method="destory"
      set依赖注入：必须生成set方法，然后在编辑配置文件
        <property name="AccountDao" ref="accountDao"></property> bean类型的注入
        <property name="Age" value="12"> 基本类型的注入，使用value
        set方式注入数组：
          <property name="MyArray">
              <array>
                  <value>a1</value>  <!-- 引用类型的话，就用<ref></ref> -->
                  <value>b2</value>
                  <value>c3</value>
              </array>
          </property>
        set方式注入map：涉及到引用类型就用ref
          <property name="MyMap">
              <map>
                  <entry key="k1" value="v1"></entry>
                  <entry key="k2" value="v2"></entry>
                  <entry key="k3" value="v3"></entry>
              </map>
          </property>
        set方式注入property：涉及到引用类型就用ref
          <property name="myProperties">
              <props>
                  <prop key="p1">vale1</prop>
                  <prop key="p1">vale2</prop>
              </props>
          </property>
        set方式注入set：涉及到引用类型就用ref
          <property name="MySet">
              <set>
                  <value>set1</value>
                  <value>set2</value>
              </set>
          </property>
      构造注入：必须生成构造方法，然后在编辑配置文件 index是参数的顺序
        <constructor-arg index="0" ref="connectionUtils"></constructor-arg>
        <constructor-arg index="1" value="MIKE"></constructor-arg>
        <constructor-arg index="2" value="12"></constructor-arg>
        或：使用name,name就是参数名，参数名！！！
        <constructor-arg name="connectionUtils" ref="connectionUtils"></constructor-arg>
        <constructor-arg name="name" value="MIKE"></constructor-arg>
        <constructor-arg name="age" value="12"></constructor-arg>

javacode02 xml+注解形式
  引入的jar与纯注解模式是一致的
  启动方式与纯注解模式是一致的
  步骤：
    STEP01.
      第三方jar中的bean定义在xml中 比如德鲁伊连接池
    STEP02.
      自己开发的bean使用注解
      假设自己开发的bean要写在xml中的bean中，那么注解的形式就是在自己bean的类的顶端写：@Component("accountDao")
      "accountDao"就是bean的id,不写的话默认是类名首字母小写
      <bean>标签使用以下注解替换：
        @Component
        @Service
        @Property
        @Controller
      <property>标签使用以下注解进行set注入：
        @Autowired 根据类型进行注入，如果容器中有多个该类型的实例，那么就要借助：@Qualifier("对象的id")
        1.加在属性上，可以删掉set方法
        2.加在set方法上
    STEP03.
      配置注解扫描以及外部配置文件读取
        <!-- 开启注解扫描  base-package指定扫描的包路径-->
        <context:component-scan base-package="com.lagou.edu"/>
        <!-- 引入外部资源.properties文件 用于读取该文件中的内容: 如：${jdbc.url} -->
        <context:property-placeholder location="classpath:jdbc.properties"/>
        <!--第三方德鲁伊dataSource配置在这里-->
        <bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
            <property name="DriverClassName" value="${jdbc.driver}"></property>
            <property name="Url" value="${jdbc.url}"></property>
            <property name="Username" value="${jdbc.username}"></property>
            <property name="Password" value="${jdbc.password}"></property>
        </bean>

javacode03 纯注解形式
  不需要xml配置文件
  STEP01.
    将javacode02中xml中的配置挪到SpringConfig.class配置类中进行配置
  STTP02.
    启动容器
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);
                                                            //配置类如果有多个的话，就以逗号的形式分来来传参
    ConnectionUtils connectionUtils1 = (ConnectionUtils) applicationContext.getBean("connectionUtils");


